# 静态链表解题套路

## 1. 定义静态链表

```cpp
struct Node{
    int address;    //结点地址
    typename data;  //数据域
    int next;        //指针域
    XXX;            //结点的某个性质，不同的题目会有不同的设置
}node[100010];
```

如上，把结点的地址、数据域、指针域都进行了定义，并且留了一个`XXX`来适应不同的题目(例如可以设置成**结点是否为链表上的一个结点**)。

## 2. 对静态链表进行初始化

在程序开始，对静态链表进行**初始化**。一般来说，需要对应以中的`XXX`进行初始化，将其定义为正常情况下达不到的数字(一般来说需要小于所有能达到的数字)，例如对结点是否在链表上这个性质来说，可以初始化为0(即false)，表示结点不在链表上。

```cpp
for(int i=0; i<MAXN; ++i){
    node[i].XXX = 0;
}
```

### 3. 遍历链表，对结点的性质XXX进行标记

题目一般都会给出一条链表的首结点的地址，那么就可以依据这个地址来遍历得到整条链表。需要注意的是，这一步同时也对结点的性质`XXX`进行标记、并且对有效结点的个数进行计数的时候，例如对结点是否在链表上这个性质来说，当遍历链表时，就可以把`XXX`置为1(即true)

```cpp
int p = begin, count = 0;
while(p != -1){    //-1代表链表结束
    XXX = 1;
    ++count;
    p = node[p]->next;
}
```

## 4. 对数组排序

由于使用静态链表时，是直接采用地址映射(hash)的方式，这就会使得数组下标的不连续，而很多时候题目给出的结点并不都是有效结点(即可能存在不在链表上的结点)。为了能够可控地访问有效结点，一般都需要用对数组进行排序把有效结点移动到数组左端，这样就可以用步骤3得到的`count`来访问它们。

在步骤2中，`XXX`需要被初始化为比正常结点的`XXX`取值要小的数值，这个做法就会在这一步起作用。使用sort的排序函数`cmp`，就可以在`cmp`的两个参数结点中有无效结点时按`XXX`从大到小排序，这样就可以把有效结点全部移动到数组左端。

一般题目会有额外的要求，因此`cmp`函数中一般都需要有第二级排序。如，当两个参数结点都是有效结点时按结点在链表中的位置从小到达排序。

```cpp
bool cmp(Node a, Node b){
    if(a.XXX == -1 || b.XXX == -1){    //至少一个结点是无效结点，就把它放到数组后面
        return a.XXX > b.XXX;
    }else{
        return a.data < b.data;    //二级排序，如果都是有效结点，就按数据值从小到大排序
    }

}
```

## 5. 打完收工

经历步骤4受，链表中的有效结点就都在数组左端了，且已经按结点的性质进行了排序。
