# 5.6 大整数运算

大整数又称为高精度整数，其含义就是用基本数据类型无法存储其精度的整数。

## 5.6.1 大整数的存储

使用**数组**即可。例如定义 int 型数组 d[1000]，那么这个数组中的每一位就代表了存放的整数的每一位。如将整数 235813 存储到数组中，则有 d[0]=3, d[1]=1, d[2]=8, d[3]=5, d[4]=3, d[5]=2，即**整数的高位存储在数组的高位，整数的地位存储在数组的低位**。因为在进行运算的时候都是从整数的低位到高位进行枚举，顺序存储和这种思维结合。

但是需要注意的的问题：把整数按字符串 `%s` 读入的时候，实际上是逆位存储的，即 str[0]='2', str[1]='3', ..., str[5]='3'，因此**在读入之后需要在另存至 d[] 数组的时候反转一下**。

为了方便随时获取大整数的长度，一般都会定义一个 int 型变量 len 来记录其长度，并和 d 数组组成成结构体：

```cpp
struct bign{
    int d[1000];
    int len;
    //构造函数是用来初始化结构体的函数，函数名和结构体名相同、无返回值
    bign(){    //在定义结构体变量之后，马上初始化结构体。
        memset(d, 0, sizeof(d));
        len = 0;
    }
};
```

输入大整数时，一般都是**先用字符串读入，然后再把字符串另存为至 bign 结构体**。

```cpp
bign change(char str[]){    //将整数转换为bign
    bign a;
    a.len = strlen(str);    //bign的长度就是字符串的长度
    for(int i=0; i<a.len; ++i){
        a.d[i] = str[a.len - i - 1] - '0';    //逆着赋值
    }
    return a;
}
```

如果要**比较两个bign变量的大小，先判断两者的len大小，如果不相等，则以长的为大；如果相等，则从高位到低位进行比较，直到出现某一位不等，就可以判断两个数的大小**。

```cpp
int compare(bign a, bign b){    //比较a和b大小，a大、相等、a小分别返回1、0、-1
    if(a.len > b.len)    return 1;    //a大
    else if(a.len < b.len)    return -1;    //a小
    else{
        for(int i=a.len-1; i>=0; --i){    //从高位往低位比较
            if(a.d[i] > b.d[i])    return 1;    //只要有一位a大，则a大
            else if(a.d[i] < b.d[i])    return -1;    //只要有一位a小，则a小
        }
    }
    return 0;    //相等
}
```

## 5.6.2 大整数的四则运算

- 高精度加法

将某位上的两个数字和进位相加，得到的结果取个位数作为该位结果，取十位数作为新的进位

```cpp
bign add(bign a, bign b){
    bign c;
    int carry = 0;    //进位
    for(int i=0; i<a.len || i<b.len; ++i){
        int tmp = a.d[i] + b.d[i] + carry;
        c.d[c.len++] = tmp % 10;
        carry = tmp / 10;    //十位数为新的进位
    }
    if(carry != 0)
        c.d[c.len++] = carry;
    return c;
}
```

- 高精度减法

对某一步，比较被减位和减位，如果不够减，则令被减位的高位减1、被减位加10再进行减法；如果够减，则直接减。最后一步要注意减法后高位可能有多余的0，要忽视它们，但要要保证结果至少有一位数。

```cpp
bign sub(bign a, bign b){    //高精度 a-b
    bign c;
    for(int i=0; i<a.len || i<b.len; ++i){
        if(a.d[i] < b.d[i]){    //如果不够减
            a.d[i+1]--;    //向高位借1
            a.d[i] += 10;
        }
        c.d[c.len++] = a.d[i] - b.d[i];    //减法结果为当前结果
    }
    while(c.len-1>=1 && c.d[c.len-1]==0){
        c.len--;    //去除高位的0，同时至少保留一位最低位
    }
    return c;
}
```

> 使用`sub`函数前要比较两个数的大小，如果被减数小于减数，需要交换两个变量，然后输出负号，再使用sub函数。

- 高精度与低精度的乘法

```cpp
bign multi(bign a, int b){
    bign c;
    int carry = 0;
    for(int i=0; i<a.len; ++i){
        int tmp = a.d[i] * b + carry;
        c.d[c.len++] = tmp % 10;
        carry /= 10;
    }
    while(carry != 0){
        c.d[c.len++] = carry % 10;
        carry /= 10;
    }
}
```

> 如果a和b中存在负数，需要先记录下其负号，然后取它们的绝对值带入函数。

- 高精度与低精度的除法

上一步的余数除以 10 加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为 0；如果够除，则商即对应的商，余数即为对应的余数。最后一步要注意除法后高位可能有多余的 0，要忽视它们。

```cpp
bign divide(bign a, int b, int &r){    //c为余数，设置为引用则可以得到余数结果
    bign c;
    c.len = a.len;    //被除数的每一位和商的每一位是一一对应的，因此先令长度相等
    for(int i=a.len-1; i>=0; --i){
        r = a.d[i] + r * 10;    //和上一位遗留的余数组合
        if(r < b){    //不够除
            c.d[i] = 0;    //该位为0
        }else{    //够除
            c.d[i] = r / b;    //商
            r = r % b;        //余数
        }
    }
    while(c.len >= 2 && c.d[len-1] == 0){
        c.len--;
    }
    return c;
}
```

> 把余数设置为引用类型，可得到除法的余数。
